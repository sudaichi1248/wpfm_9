/*
 * File:    sensor.c
 * Author:  Interark Corp.
 * Summary: Analog Sensor control implementation file.
 * Date:    2022/08/13 (R0)
 * Note:    Points to be adjusted where ""@tune" is listed
 */

//#define DEBUG_UART

#include "debug.h"
#include "wpfm.h"
#include "util.h"
#include "gpioexp.h"
#include "sensor.h"

/*
*   Symbols and Constants
*/
#define NUM_TIMES_ACTUALLY              10              // The number of times the value is actually read in one measurement (@specify by customer)
#define WAIT_TIME_FOR_EACH_MEASUREMENT  10              // Free time for continuous measurements[mS] (@tune)
#define SHUNT_REGISTANCE                150             // for current output sensor [ohm]

/*
*   Global variables
*/
bool SENSOR_alwaysOnSensorPower = false;

const static float _SENSOR_conversionFactor                = 0.000990000;      // Conversion to voltage factor [V/LSB]
const static float _SENSOR_dividedRatioOfVoltageSensor     = 1.69757; //1.66667;          // JP1/JP2 -> MAX3V Setting、実際には実測(Board $22-005)により補正
const static float _SENSOR_dividedRatioOfExternalBattery   = 1.52710; //1.52308;          // 回路上は1.50000、実際には実測(Board $22-005)により補正


int SENSOR_readSensorOutput(int sensorNo, float *result_p)
{
    DEBUG_UART_printlnFormat("> SENSOR_readSensorOutput(%d,-)", sensorNo);
    *result_p = WPFM_MISSING_VALUE_FLOAT;

    int sensorIndex;
    switch (sensorNo)
    {
        case 1:
            ADC_ChannelSelect(SENDOR_CHANNEL_IN1, ADC_NEGINPUT_GND);
            sensorIndex = 0;
            break;
        case 2:
            ADC_ChannelSelect(SENDOR_CHANNEL_IN2, ADC_NEGINPUT_GND);
            sensorIndex = 1;
            break;
        default:
            return (SENSOR_ERR_PARAM);
    }
    int sensorKind = WPFM_settingParameter.sensorKinds[sensorIndex];
    DEBUG_UART_printlnFormat("sensorIndex=%d,sensorKind=%d", sensorIndex, sensorKind);

    int sensorKindIndex = sensorKind - 1;
    float result = 0.0, volt = 0.0, mA = 0.0;
    uint16_t rawValue = 0, calibratedRawValue = 0;
    switch (sensorKind)
    {
        case SENSOR_KIND_1_3V:
            // (1) read raw value using ADC
            rawValue = SENSOR_readRawValue();
            // (2) Callibrate raw value
            calibratedRawValue = UTIL_map(rawValue, 0, 4095,
                    WPFM_settingParameter.calibrationLowerValues[sensorIndex][sensorKindIndex],
                    WPFM_settingParameter.calibrationUpperValues[sensorIndex][sensorKindIndex]
            );
            DEBUG_UART_printlnFormat("calibratedRawValue=%u", calibratedRawValue);
            // (3) Fix it to fit the catalog specification range(lower..upper)
            if (calibratedRawValue < WPFM_settingParameter.lowerLimits[sensorIndex])
            {
                calibratedRawValue = WPFM_settingParameter.lowerLimits[sensorIndex];
            }
            else if (calibratedRawValue > WPFM_settingParameter.upperLimits[sensorIndex])
            {
                calibratedRawValue = WPFM_settingParameter.upperLimits[sensorIndex];
            }
            DEBUG_UART_printlnFormat("fixed calibratedRawValue=%u", calibratedRawValue);
            // (4) Calculate the actual sensor output voltage
            volt = calibratedRawValue * _SENSOR_dividedRatioOfVoltageSensor * _SENSOR_conversionFactor;
            DEBUG_UART_printlnFormat("volt=%.3f", volt);
            result = volt;
            break;
        case SENSOR_KIND_1_5V:
            // (1) read raw value using ADC
            rawValue = SENSOR_readRawValue();
            // (2) Callibrate raw value
            calibratedRawValue = UTIL_map(rawValue, 0, 4095,
                    WPFM_settingParameter.calibrationLowerValues[sensorIndex][sensorKindIndex],
                    WPFM_settingParameter.calibrationUpperValues[sensorIndex][sensorKindIndex]
            );
            DEBUG_UART_printlnFormat("calibratedRawValue=%u", calibratedRawValue);
            // (3) Fix it to fit the catalog specification range(lower..upper)
            if (calibratedRawValue < WPFM_settingParameter.lowerLimits[sensorIndex])
            {
                calibratedRawValue = WPFM_settingParameter.lowerLimits[sensorIndex];
            }
            else if (calibratedRawValue > WPFM_settingParameter.upperLimits[sensorIndex])
            {
                calibratedRawValue = WPFM_settingParameter.upperLimits[sensorIndex];
            }
            DEBUG_UART_printlnFormat("fixed calibratedRawValue=%u", calibratedRawValue);
            // (4) Calculate the actual sensor output voltage
            volt = calibratedRawValue * _SENSOR_dividedRatioOfVoltageSensor * _SENSOR_conversionFactor;
            DEBUG_UART_printlnFormat("volt=%.3f", volt);
            result = volt;
            break;
        case SENSOR_KIND_0_20MA:
            // (1) read raw value using ADC
            rawValue = SENSOR_readRawValue();
            // (2) Callibrate raw value
            calibratedRawValue = UTIL_map(rawValue, 0, 4095,
                    WPFM_settingParameter.calibrationLowerValues[sensorIndex][sensorKindIndex],
                    WPFM_settingParameter.calibrationUpperValues[sensorIndex][sensorKindIndex]
            );
            DEBUG_UART_printlnFormat("calibratedRawValue=%u", calibratedRawValue);
            // (3) Fix it to fit the catalog specification range(lower..upper)
            if (calibratedRawValue < WPFM_settingParameter.lowerLimits[sensorIndex])
            {
                calibratedRawValue = WPFM_settingParameter.lowerLimits[sensorIndex];
            }
            else if (calibratedRawValue > WPFM_settingParameter.upperLimits[sensorIndex])
            {
                calibratedRawValue = WPFM_settingParameter.upperLimits[sensorIndex];
            }
            DEBUG_UART_printlnFormat("fixed calibratedRawValue=%u", calibratedRawValue);
            // (4) Calculate the actual sensor output current
            volt = calibratedRawValue * _SENSOR_dividedRatioOfVoltageSensor;
            mA = (volt / (float)SHUNT_REGISTANCE) * 1000.0;
            DEBUG_UART_printlnFormat("volt=%.3f,mA=%.3f", volt, mA);
            result = mA;
            break;
        case SENSOR_KIND_4_20MA:
            // (1) read raw value using ADC
            rawValue = SENSOR_readRawValue();
            // (2) Callibrate raw value
            calibratedRawValue = UTIL_map(rawValue, 0, 4095,
                    WPFM_settingParameter.calibrationLowerValues[sensorIndex][sensorKindIndex],
                    WPFM_settingParameter.calibrationUpperValues[sensorIndex][sensorKindIndex]
            );
            DEBUG_UART_printlnFormat("calibratedRawValue=%u", calibratedRawValue);
            // (3) Fix it to fit the catalog specification range(lower..upper)
            if (calibratedRawValue < WPFM_settingParameter.lowerLimits[sensorIndex])
            {
                calibratedRawValue = WPFM_settingParameter.lowerLimits[sensorIndex];
            }
            else if (calibratedRawValue > WPFM_settingParameter.upperLimits[sensorIndex])
            {
                calibratedRawValue = WPFM_settingParameter.upperLimits[sensorIndex];
            }
            DEBUG_UART_printlnFormat("fixed calibratedRawValue=%u", calibratedRawValue);
            // (4) Calculate the actual sensor output current
            volt = calibratedRawValue * _SENSOR_dividedRatioOfVoltageSensor;
            mA = (volt / (float)SHUNT_REGISTANCE) * 1000.0;
            DEBUG_UART_printlnFormat("volt=%.3f,mA=%.3f", volt, mA);
            result = mA;
            break;
        case SENSOR_KIND_NOT_PRESENT:
            // specified sensor is not exist.
            return (SENSOR_ERR_NOT_EXIST);
        default:
            return (SENSOR_ERR_PARAM);
    }

    *result_p = result;

    DEBUG_UART_printlnFormat("< SENSOR_readSensorOutput(%d,-) OK: %.3f", sensorNo, result);
    return (SENSOR_ERR_NONE);
}

int SENSOR_readExternalBatteryVoltage(int externalNo, uint16_t *voltage_p)
{
    DEBUG_UART_printlnFormat("> SENSOR_readExternalBatteryVoltage(%d,-)", externalNo);
    *voltage_p = WPFM_MISSING_VALUE_UINT16;

    switch (externalNo)
    {
        case 1:
            ADC_ChannelSelect(SENSOR_EXTERNAL_BATTERY1, ADC_NEGINPUT_GND);
            break;
        case 2:
            ADC_ChannelSelect(SENSOR_EXTERNAL_BATTERY2, ADC_NEGINPUT_GND);
            break;
        default:
            return (SENSOR_ERR_PARAM);
    }

    float result = SENSOR_readRawValue() * _SENSOR_dividedRatioOfExternalBattery * _SENSOR_conversionFactor;
    *voltage_p = (uint16_t)(result * 1000.0);      // Convert Volt to milli Volt

    DEBUG_UART_printlnFormat("< SENSOR_readExternalBatteryVoltage(%d,-) OK: %.3f", externalNo, result);
    return (SENSOR_ERR_NONE);
}

int SENSOR_turnOnSensorCircuit(int sensorNo, bool sensorPowered)
{
    DEBUG_UART_printlnFormat("SENSOR_turnOnSensorCircuit(%d,%d)", sensorNo, sensorPowered);

    switch (sensorNo)
    {
        case 1:
            GPIOEXP_set(WPFM_GPIO_CH1_PWR);
            if (sensorPowered)
            {
                GPIOEXP_set(WPFM_GPIO_CH1_EXT_PWR);
            }
            break;
        case 2:
            GPIOEXP_set(WPFM_GPIO_CH2_PWR);
            if (sensorPowered)
            {
                GPIOEXP_set(WPFM_GPIO_CH2_EXT_PWR);
            }
            break;
        default:
            return (SENSOR_ERR_PARAM);
    }

    return (SENSOR_ERR_NONE);
}

int SENSOR_turnOffSensorCircuit(int sensorNo)
{
    DEBUG_UART_printlnFormat("SENSOR_turnOffSensorCircuit(%d)", sensorNo);

    switch (sensorNo)
    {
        case 1:
            GPIOEXP_clear(WPFM_GPIO_CH1_PWR);
            GPIOEXP_clear(WPFM_GPIO_CH1_EXT_PWR);
            break;
        case 2:
            GPIOEXP_clear(WPFM_GPIO_CH2_PWR);
            GPIOEXP_clear(WPFM_GPIO_CH2_EXT_PWR);
            break;
        default:
            return (SENSOR_ERR_PARAM);
    }

    return (SENSOR_ERR_NONE);
}

void SENSOR_updateMeasurementInterval(uint16_t interval)
{
    if (interval == WPFM_measurementInterval)
    {
        return;     // nothing to do
    }

    WPFM_measurementInterval = interval;

    if (SENSOR_alwaysOnSensorPower)
    {
        if (interval >= WPFM_THRESHOLD_FOR_SENSOR_POWER_CONTROL)
        {
            SENSOR_alwaysOnSensorPower = false;
            for (int sensorIndex = 0; sensorIndex < 2; sensorIndex++)
            {
                if (WPFM_settingParameter.sensorKinds[sensorIndex] != SENSOR_KIND_NOT_PRESENT)
                {
                    SENSOR_turnOffSensorCircuit(sensorIndex + 1);
                }
            }
        }
    }
    else
    {
        if (interval < WPFM_THRESHOLD_FOR_SENSOR_POWER_CONTROL)
        {
            SENSOR_alwaysOnSensorPower = true;
            for (int sensorIndex = 0; sensorIndex < 2; sensorIndex++)
            {
                uint8_t sensorKind = WPFM_settingParameter.sensorKinds[sensorIndex];
                if (sensorKind != SENSOR_KIND_NOT_PRESENT)
                {
                    SENSOR_turnOnSensorCircuit(sensorIndex + 1, (sensorKind == SENSOR_KIND_1_3V));
                }
            }
        }
    }
}

uint16_t SENSOR_readRawValue(void)
{
    ADC_Enable();       // -- Start ADC --

    uint32_t sum = 0;
    for (int i = 0; i < NUM_TIMES_ACTUALLY; i++)
    {
        ADC_ConversionStart();
        while (! ADC_ConversionStatusGet())
            ;
        sum += ADC_ConversionResultGet();

        // APP_delay(WAIT_TIME_FOR_EACH_MEASUREMENT);     // wait a little (@tune)
        SYSTICK_DelayMs(WAIT_TIME_FOR_EACH_MEASUREMENT);
    }

    ADC_Disable();      // -- STOP ADC --
    uint16_t rawValue = ((float)sum / (float)NUM_TIMES_ACTUALLY);
    DEBUG_UART_printlnFormat("SENSOR_readRawValue() OK: %u", rawValue);

    return (rawValue);
}
